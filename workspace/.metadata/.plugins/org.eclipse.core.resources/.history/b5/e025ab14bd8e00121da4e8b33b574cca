package weka.subspaceClusterer;

import Jama.Matrix;

public class Pca {

	// Pick a small values that means zero.
	public static double epsilon = 1E-8;

	public static Matrix centered(Matrix input, Matrix columnMeans) {
		int rows = input.getRowDimension();
		int cols = input.getColumnDimension();
		Matrix mat = new Matrix(rows, cols);
		double val, mean;
		for (int i = 0; i < rows; ++i) {
			for (int j = 0; j < cols; ++j) {
				val = input.get(i, j);
				mean = columnMeans.get(0, j);
				mat.set(i, j, val - mean);
			}// end for
		}// end for
		return mat;
	}// end method

	public static double dotProduct(Matrix colVec1, Matrix colVec2) {
		double sum = 0;
		int rows1 = colVec1.getRowDimension();
		int rows2 = colVec2.getRowDimension();
		if (rows1 != rows2) {
			System.err.println("Dimension error in Pca.dotProduct.");
		}// end if

		for (int i = 0; i < rows1; ++i) {
			sum += colVec1.get(i, 0) * colVec2.get(i, 0);
		}// end for

		return sum;

	}// end method

	public static Matrix columnMeans(Matrix input) {

		int cols = input.getColumnDimension();
		int rows = input.getRowDimension();
		Matrix rowVector = new Matrix(1, cols);
		double sum;
		for (int j = 0; j < cols; ++j) {
			sum = 0;
			for (int i = 0; i < rows; ++i) {
				sum += input.get(i, j);
			}// end for
			rowVector.set(0, j, sum / rows);
		}// end for
		return rowVector;
	}// end method

	public static Matrix columnSums(Matrix input) {
		int cols = input.getColumnDimension();
		int rows = input.getRowDimension();
		Matrix mat = new Matrix(1, cols);
		double sum;
		for (int j = 0; j < cols; ++j) {
			sum = 0;
			for (int i = 0; i < rows; ++i) {
				sum += input.get(i, j);
			}// end for
			mat.set(0, j, sum);
		}// end for
		return mat;
	}// end method

	// public static Matrix rotate(Matrix input, Matrix tranform) {
	//
	// }

	// Constructor
	public Pca(Matrix input) throws Exception {
		eval();
	}

	public static Matrix covariance(Matrix input) {
		// PRECONDITION: MATRIX MUST BE MEAN-CENTERED
		// Allocate the covariance matrix
		int rows = input.getRowDimension();
		int cols = input.getColumnDimension();
		Matrix covMatrix = new Matrix(cols, cols);

		// Compute the covariance matrix
		double covar_ij;
		Matrix colVec1, colVec2;
		for (int i = 0; i < cols; ++i) {
			for (int j = i; j < cols; ++j) {

				colVec1 = input.getMatrix(0, rows - 1, i, i);
				colVec2 = input.getMatrix(0, rows - 1, j, j);
				covar_ij = dotProduct(colVec1, colVec2) / (rows - 1);
				covMatrix.set(i, j, cov_ij);
				covMatrix.set(i, j, cov_ij);
			}// end for
		}// end for

		return covMatrix;
	}// end method

	public void eval() {
		// // Set instance variables
		//
		// // Rank tell us the maximum number of non-zero eigenvalues to expect.
		// int covRank = cov.rank();
		//
		// // Calculate the eigvenvectors and eigenvalues of the covariance
		// matrix
		// / EigenvalueDecomposition eigenDecomp = cov.eig();
		//
		// // Count number of principal components
		// double[] eigenvalues = eigenDecomp.getRealEigenvalues();
		// int numNonZeroEigenVals = 0;
		// for (int i = 0; i < eigenvalues.length; ++i) {
		// if (eigenvalues[i] > epsilon) {
		// numNonZeroEigenVals++;
		// }
		// }
		//
		// // Verify number of non zero eigenvalues is the same as the rank of
		// the
		// // covariance matrix
		// if (numNonZeroEigenVals != covRank) {
		// System.out.println("SOMETHING WHACKY IN PCA");
		// }
		//
		// /*
		// * The principal components will be column vectors in the eigenvector
		// * matrix. The eigenvector matrix will always be a (pxp) matrix, same
		// as
		// * the covariance matrix. ***I think*** The principal components are
		// * listed in order of increasing significance. This works well for my
		// * purposes because the least significant components are orthogonal
		// the
		// * dimension were the data congregates.
		// */
		// Matrix eigenvectors = eigenDecomp.getV();
		//
		// // Silly sanity check. Probably not needed.
		// int size = eigenvectors.getRowDimension();
		// if (size != eigenvectors.getColumnDimension()) {
		// System.out.println("EIGEN VECTORS SHOULD BE SQUARE MATRIX");
		// }
		//
		// /*
		// * The eigenvectors matrix can contain garbage. If the eigenvalue is
		// * smaller than some epsilon, it must be considered zero and the
		// * corresponding eigenvector discarded.
		// *
		// * getMatrix(Initial row index, Final row index, Initial column index,
		// * Final column index)
		// */
		// int last = size - 1;
		// int firstCol = size - covRank;
		// components = eigenvectors.getMatrix(0, last, firstCol, last);
		// return this;
		//
	}// end method

}// end class
