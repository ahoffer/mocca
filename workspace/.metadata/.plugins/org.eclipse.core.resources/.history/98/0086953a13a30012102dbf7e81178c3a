package weka.subspaceClusterer;

import i9.subspace.base.Cluster;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.TreeMap;

import org.supercsv.io.CsvListWriter;
import org.supercsv.prefs.CsvPreference;

public class ResultsWriter {
    static String clustererExpKey = "EXP";
    static String clustererNameKey = "ALGO";
    static String dataNameKey = "DATA";
    static String extension = ".csv";

    String path;

    /* The name of a measure or parameter (key) and either the measurement or the value of the parameter */
    TreeMap<String, String> output = new TreeMap<String, String>();

    public void put(String name, Double value) {
        output.put(name, ntoa(value));
    }

    public void setPath(String path) {
        this.path = path;
    }

    public void writeResults() throws Exception {

        CsvListWriter writer = getListWriter("RSLT");
        String[] header = output.navigableKeySet().toArray(new String[0]);
        writer.writeHeader(header);
        writer.write(output.values().toArray(new String[0]));
        writer.close();
    }

    public void writeClusters(ArrayList<Cluster> clusters) throws Exception {
        CsvListWriter writer = getListWriter("CLSTR");
        writer.writeHeader(getClusterHeader(clusters.get(0)));
        for (Cluster each : clusters) {

        }
    }

    File getFile(String name) {
        return new File(getPath() + getKey() + "_" + name + extension);
    }

    CsvListWriter getListWriter(String name) {

        File file = getFile(name);
        CsvListWriter temp = null;
        try {
            temp = new CsvListWriter(new FileWriter(file.getCanonicalFile()),
                    new CsvPreference.Builder('"', ',', "\n").build());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return temp;
    }

    public String getKey() {
        return output.get(clustererExpKey);
    }

    public String getPath() {
        return path;
    }

    public void setKey(String key) {
        output.put(clustererExpKey, key);
    }

    public void setClustererName(String name) {
        output.put(clustererNameKey, name);
    }

    public void setDataName(String name) {
        output.put(dataNameKey, name);
    }

    List<String> getRecord(MoccaCluster cluster) {
        ArrayList<String> list = new ArrayList<String>();

        // If MOCCA cluster, add in quality metric for the cluster
        list.add(ntoa(cluster.quality));
        list.addAll(getRecord((Cluster) cluster));
        return list;
    }

    private List<String> getRecord(Cluster cluster) {
        ArrayList<String> list = new ArrayList<String>();
        StringBuffer subspace = new StringBuffer();
        StringBuffer objs = new StringBuffer();

        // Subspace
        subspace.append('[');
        for (boolean each : cluster.m_subspace) {
            subspace.append(each ? '1' : '0');
        }
        subspace.append(']');
        list.add(subspace.toString());

        // Cardinality of object set
        list.add(ntoa(cluster.m_objects.size()));

        // Indexes of the object set
        objs.append('[');
        for (Integer each : cluster.m_objects) {
            objs.append(each);
        }
        objs.append(']');
        list.add(objs.toString());

        return list;
    }

    String ntoa(Double val) {
        return String.format("%f", val);
    }

    String ntoa(int val) {
        return String.format("%d", val);
    }

    String[] getClusterHeader(Cluster cluster) {
        ArrayList<String> list = new ArrayList<String>();
        list.add("SUBSPACE");
        list.add("CARDINALITY");
        list.add("OBJECTS");
        return list.toArray(new String[0]);
    }

    List<String> getClusterHeader(MoccaCluster cluster) {
        ArrayList<String> list = new ArrayList<String>();

        list.add("QUALITY");
        list.addAll(getClusterHeader((Cluster) cluster));
        return list;
    }

}// class

