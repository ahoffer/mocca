package weka.subspaceClusterer;

import Jama.EigenvalueDecomposition;
import Jama.Matrix;

public class Pca {

	// Instance variables
	Matrix input;
	Matrix principleComponents;
	Matrix output;



	// Constructor
	public Pca(Matrix input) {
		this.input = input;
		eval();
	}

	public static Matrix covariance(Matrix input) {
		// PRECONDITION: MATRIX MUST BE MEAN-CENTERED
		// Allocate the covariance matrix
		int rows = input.getRowDimension();
		int cols = input.getColumnDimension();
		Matrix covMatrix = new Matrix(cols, cols);

		// Compute the covariance matrix
		double covar_ij;
		Matrix colVec1, colVec2;
		for (int i = 0; i < cols; ++i) {
			for (int j = i; j < cols; ++j) {

				colVec1 = input.getMatrix(0, rows - 1, i, i);
				colVec2 = input.getMatrix(0, rows - 1, j, j);
				covar_ij = dotProduct(colVec1, colVec2) / (rows - 1);
				covMatrix.set(i, j, covar_ij);
				covMatrix.set(j, i, covar_ij);
			}// end for
		}// end for

		return covMatrix;
	}// end method

	public Pca eval() {
		Matrix covar = covariance(center(input, columnMeans(input)));
		// Rank tell us the maximum number of non-zero eigenvalues to expect.
		int covRank = covar.rank();

		// Calculate the eigenvectors and eigenvalues of the covariance
		EigenvalueDecomposition eigenDecomp = covar.eig();

		// Count number of principal components
		double[] eigenvalues = eigenDecomp.getRealEigenvalues();
		int numNonZeroEigenVals = 0;
		for (int i = 0; i < eigenvalues.length; ++i) {
			if (eigenvalues[i] > epsilon) {
				numNonZeroEigenVals++;
			}// end if
		}// end for

		// Verify number of non zero eigenvalues is the same as the rank of
		// the covariance matrix
		if (numNonZeroEigenVals != covRank) {
			System.err.println("SOMETHING WHACKY IN PCA");
		}

		/*
		 * The principal components will be column vectors in the eigenvector
		 * matrix. The eigenvector matrix will always be a (pxp) matrix, same as
		 * the covariance matrix. ***I think*** The principal components are
		 * listed in order of increasing significance. This works well for my
		 * purposes because the least significant components are orthogonal the
		 * dimension were the data congregates.
		 */
		Matrix eigenvectors = eigenDecomp.getV();

		/*
		 * The eigenvectors matrix can contain garbage. If the eigenvalue is
		 * smaller than some epsilon, it must be considered zero and the
		 * corresponding eigenvector discarded.
		 * 
		 * getMatrix(Initial row index, Final row index, Initial column index,
		 * Final column index)
		 */
		int size = eigenvectors.getRowDimension();
		int last = size - 1;
		int firstCol = size - covRank;
		principleComponents = eigenvectors.getMatrix(0, last, firstCol, last);

		// Rotate the input
		output = input.times(principleComponents);

		// Return this instance
		return this;

	}// end method
}// end class
