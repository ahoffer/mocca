package weka.subspaceClusterer;

public class MoccaSubspace {

	private boolean[] subspace;
	int numDims, numCongregatingDims;
	double[][] discrimObjs;
	double width;
	private double[] lower;
	private double[] upper;

	public MoccaSubspace(double[][] discrimObjs, double width, int numDims) {
		this.discrimObjs = discrimObjs;
		this.width = width;
		this.numDims = numDims;
	}

	public void eval() {

		double sheath;

		/*
		 * Create max and min values in each dimension from the discriminating
		 * set. Find the subspace and number of congregating dimensions
		 */
		double[] minimums = MoccaUtils.min(discrimObjs);
		double[] maximums = MoccaUtils.max(discrimObjs);
		double lengths[] = MoccaUtils.subtract(maximums, minimums);

		subspace = MoccaUtils.lessThanOrEqualTo(lengths, width);
		numCongregatingDims = MoccaUtils.countTrueValues(getSubspace());

		/*
		 * If the entire subspace is zero, it means the discriminating set does
		 * not congregate in any dimension. The trial has failed to find a
		 * cluster
		 */
		if (numCongregatingDims > 0) {

			/*
			 * Calculate upper and lower bounds of the hyper volume that
			 * surrounds the cluster.
			 */

			for (int i = 0; i < numDims; ++i) {
				sheath = width - lengths[i];
				lower[i] = minimums[i] - sheath;
				upper[i] = maximums[i] + sheath;
			}

		}// if
	}// method

	/**
	 * @return the subspace
	 */
	public boolean[] getSubspace() {

		return subspace.clone();
	}

	/**
	 * @return the lower
	 */
	public double[] getLower() {
		return lower;
	}

	/**
	 * @param lower the lower to set
	 */
	public void setLower(double[] lower) {
		this.lower = lower;
	}

	/**
	 * @return the upper
	 */
	double[] getUpper() {
		return upper;
	}

	/**
	 * @param upper the upper to set
	 */
	void setUpper(double[] upper) {
		this.upper = upper;
	}

}
