package weka.subspaceClusterer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;

import Jama.Matrix;

import weka.core.Instances;
import weka.filters.Filter;

public class StatUtils {

	// Instance variables
	weka.filters.unsupervised.instance.Resample sampler;
	Random random;

	public static double one = 0.99999;

	// Set loop invariants
	public StatUtils(int seed, Instances data) throws Exception {
		sampler = new weka.filters.unsupervised.instance.Resample();
		sampler.setRandomSeed(seed); // Make successive runs repeatable.
		sampler.setInputFormat(data);
		sampler.setNoReplacement(true);
		random = new Random(seed);
	}

	public Instances subSampleAmount(Instances dataSet, int num) {
		Instances shuffleCopy = new Instances(dataSet);
		shuffleCopy.randomize(random);
		return new Instances(dataSet, 0, num);
	} // end

	public Instances subSamplePercentage(Instances dataSet, double percentage)
			throws Exception {

		if (percentage >= one) {
			return new Instances(dataSet);
		}

		sampler.setSampleSizePercent(percentage);
		return Filter.useFilter(dataSet, sampler);
	}// end method

	// Return the largest value from each column
	public static Matrix min(Matrix input) {
		int cols = input.getColumnDimension();
		Matrix mins = new Matrix(1, cols);
		double smallest, val;
		for (int j = 0; j < cols; ++j) {
			smallest = Double.POSITIVE_INFINITY;
			for (int i = 0; i < input.getRowDimension(); ++i) {
				val = input.get(i, j);
				if (val < smallest) {
					smallest = val;
				}// end if
				mins.set(0, j, smallest);
			}// end for
		}// end for
		return mins;
	}// end method

	// Return the largest value from each column
	public static Matrix max(Matrix input) {
		int cols = input.getColumnDimension();
		Matrix maxs = new Matrix(1, cols);
		double largest, val;
		for (int j = 0; j < cols; ++j) {
			largest = Double.NEGATIVE_INFINITY;
			for (int i = 0; i < input.getRowDimension(); ++i) {
				val = input.get(i, j);
				if (val > largest) {
					largest = val;
				}// end if
				maxs.set(0, j, largest);
			}// end for
		}// end for
		return maxs;
	}// end method

	public List<Integer> sampleNoReplacement(int[] array, int sampleSize) {
		// TODO: This is inefficient when the sample size if small compared to
		// the list of the list
		//
		// TODO: I'm too lazy to code up a fisher-yates shuffle. It would be
		// good practice, though. Then I could jump the java collection classes.
		//

		ArrayList<Integer> listCopy = toList(array);

		// Shuffle the list
		Collections.shuffle(listCopy);

		// Extract the samples.
		return listCopy.subList(0, sampleSize - 1);

	}// end method

	public ArrayList<Integer> toList(int input[]) {
		ArrayList<Integer> list = new ArrayList<Integer>();
		for (int value : input) {
			list.add(value);
		}
		return list;
	}

	public int[] toArray(List<Integer> input) {
		int size = input.size();
		int array[] = new int[size];
		for (int i = 0; i < size; ++i) {
			array[i] = input.get(i).intValue();
		}// end for

		return array;

	}// end ethod

}// end class
