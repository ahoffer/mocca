package weka.subspaceClusterer;

import weka.core.Instance;
import Jama.Matrix;


public class Pca {

	// Pick a small values that means zero.
	public static double epsilon = 1E-8;


	public static Matrix columnMeans(Matrix input) {
		
		int cols = input.getColumnDimension();
		int rows = input.getRowDimension();
		Matrix rowVector = new Matrix(1, cols, 0);
		double sum;
		for (int j=0; j<cols; ++j) {
			sum = 0; 
			for (int i=0; i<rows; ++i) {
				sum += input.get(i,j);
			}//end for
			rowVector.set(1,j, sum/rows);
		}//end for
		return rowVector;
	}//end method
	
	public static Matrix centered(Matrix input, Matrix columnMeans) {
		int rows = input.getRowDimension();
		int cols = input.getColumnDimension();
		Matrix mat = new Matrix(rows, cols);
		double val, mean;
		for (int i=0; i<rows; ++i) {
			for (int j=0; j<cols; ++j) {
				val = input.get(i, j);
				mean = columnMeans.get(1,j);
			mat.set(i,j, val-mean);	
			}//end for
	}//end for
	}//end matrix
	
public static Matrix covariance(Matrix input)
// Now compute the covariance matrix
		for (int i = 0; i < dims; i++) {
			for (int j = i; j < dims; j++) {
				double cov_ij, sum = 0;
				for (int k = 0; k < numInst; k++) {
					Instance inst = input.instance(k);
					sum += inst.value(i) * inst.value(j);
				}// end for k
				cov_ij = sum / (numInst - 1);
				covMatrix.set(i, j, cov_ij);
				covMatrix.set(j, i, cov_ij);
			}// end for j
		}// end for k
		return covMatrix;
	}// end method

	public Matrix covariance(Matrix input) throws Exception {
		// Allocate the covariance matrix
		int p = input.getColumnDimension();
		int numInst = input.getRowDimension();
		Matrix covMatrix = new Matrix(p, p);

		// Compute the covariance matrix
		for (int i = 0; i < p; i++) {
			for (int j = i; j < p; j++) {
				double cov_ij, sum = 0;
				for (int k = 0; k < numInst; k++) {
					sum += inst.value(i) * inst.value(j);
				}// end for k
				cov_ij = sum / (numInst - 1);
				covMatrix.set(i, j, cov_ij);
				covMatrix.set(j, i, cov_ij);
			}// end for j
		}// end for k
		return covMatrix;
	}// end method

	// public static Matrix rotate(Matrix input, Matrix tranform) {
	//
	// }

	// Instance variables
	private Matrix components;
	private Matrix centeredData;
	private Instances rotatedOutput;
	private Matrix data;
	private Instances input;
	private Matrix columnMeans;
	private int numAttribs;
	private int numInst;

	// Constructor
	public Pca(Instances input) throws Exception {
		this.input = input;
		eval();
	}

	public Pca eval() throws Exception {
		// Set instance variables
		numAttribs = input.numAttributes();
		numInst = input.numInstances();

		calcColumnMeans();

		// Center the data by subtracting the column means
		Matrix cov = covariance(center(input));

		// Rank tell us the maximum number of non-zero eigenvalues to expect.
		int covRank = cov.rank();

		// Calculate the eigvenvectors and eigenvalues of the covariance matrix
		EigenvalueDecomposition eigenDecomp = cov.eig();

		// Count number of principal components
		double[] eigenvalues = eigenDecomp.getRealEigenvalues();
		int numNonZeroEigenVals = 0;
		for (int i = 0; i < eigenvalues.length; ++i) {
			if (eigenvalues[i] > epsilon) {
				numNonZeroEigenVals++;
			}
		}

		// Verify number of non zero eigenvalues is the same as the rank of the
		// covariance matrix
		if (numNonZeroEigenVals != covRank) {
			System.out.println("SOMETHING WHACKY IN PCA");
		}

		/*
		 * The principal components will be column vectors in the eigenvector
		 * matrix. The eigenvector matrix will always be a (pxp) matrix, same as
		 * the covariance matrix. ***I think*** The principal components are
		 * listed in order of increasing significance. This works well for my
		 * purposes because the least significant components are orthogonal the
		 * dimension were the data congregates.
		 */
		Matrix eigenvectors = eigenDecomp.getV();

		// Silly sanity check. Probably not needed.
		int size = eigenvectors.getRowDimension();
		if (size != eigenvectors.getColumnDimension()) {
			System.out.println("EIGEN VECTORS SHOULD BE SQUARE MATRIX");
		}

		/*
		 * The eigenvectors matrix can contain garbage. If the eigenvalue is
		 * smaller than some epsilon, it must be considered zero and the
		 * corresponding eigenvector discarded.
		 * 
		 * getMatrix(Initial row index, Final row index, Initial column index,
		 * Final column index)
		 */
		int last = size - 1;
		int firstCol = size - covRank;
		components = eigenvectors.getMatrix(0, last, firstCol, last);
		return this;

	}// end method

	public Matrix getComponents() {
		return components;
	}
}// end class
