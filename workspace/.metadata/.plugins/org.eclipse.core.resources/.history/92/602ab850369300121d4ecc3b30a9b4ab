package weka.subspaceClusterer;

import java.util.Arrays;
import java.util.Random;

public class Shuffler {

	private int[] ringBuffer;
	private int[] originalValues;
	private Random random;
	private long seed;
	private int fetchIdx;
	private int numberOfElements;

	public Shuffler(int numberOfElements, long seed) {
		this.seed = seed;
		random = new Random(seed);
		this.numberOfElements = numberOfElements;
		originalValues = getSequence(numberOfElements);
		reshuffle();
	}// method

	int[] getSequence(int numberOfElements) {

		// Return a sequence that ranges from 0 to numberofElements-1
		int sequence[] = new int[numberOfElements];

		for (int i = 0; i < numberOfElements; ++i) {
			sequence[i] = i;
		}// for

		return sequence;

	}// method

	public long getSeed(long seed) {
		return seed;
	}

	public void setSeed(long s) {
		seed = s;
		random = new Random(seed);
	}

	private void shuffle(int[] array) {

		// Fisher Yates shuffle
		int size, j, temp;

		size = array.length;
		for (int i = size - 1; i > 0; --i) {

			// Upper bound on random integer is exclusive, so add 1
			// Actually, I might get a better shuffle with just i
			// because there is zero chance an element can stay where it is
			j = random.nextInt(i + 1);
			temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}// for
	}// method

	public int[] next(int sampleSize) {
		int probe;
		int[] sample;

		if (sampleSize > numberOfElements) {
			// Not supported
			return null;
		}

		if (sampleSize < numberOfElements - fetchIdx) {

			fetchIdx += sampleSize;
		}
		return sample;

	}// method

	private int[] copy() {

		return Arrays.copyOf(originalValues, numberOfElements);
	}

	private void reshuffle() {
		ringBuffer = copy();
		shuffle(ringBuffer);
		fetchIdx = 0;
	}

}// class
