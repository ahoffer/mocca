package weka.subspaceClusterer;

import i9.subspace.base.ArffStorage;
import i9.subspace.sepc.SepcWrapper;
import java.util.Enumeration;
import java.util.Vector;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.Utils;

public class Mocca extends SubspaceClusterer implements OptionHandler {
	private static final long serialVersionUID = 5624336775621682596L;
	private double alpha = 0.08;
	private double beta = 0.35; // trade-off between num dims and num instances
	private double epsilon = 0.05; // chance of failing to find a cluster
	private double width = 100.0;
	private double instanceOverlapThreshold = 0.50;
	private double subspaceOverlapThreshold = 0.20;

	// Zero means "do not use PCA"
	private double gamma = 0.00;

	@Override
	public void buildSubspaceClusterer(Instances data) throws Exception {

		// Create an ARFF storage object from the Instances object
		// What is the advantage of that?
		ArffStorage arffstorage = new ArffStorage(data);

		// TODO
		// Call setSubscapceClusster(List<Cluster>)
		// setSubspaceClustering();

		// Print results
		toString();
	}

	/**
	 * Returns an enumeration of all the available options.
	 * 
	 * @return Enumeration An enumeration of all available options.
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Enumeration listOptions() {
		Vector vector = new Vector();
		
		 //Option(description, name, numArguments, synopsis)		
		vector.addElement(new Option("\talpha (default = 0.08)", "alpha", 1,
				"-a <double>"));
		vector.addElement(new Option("\tbeta (default = 0.35)", "beta", 1,
				"-b <double>"));
		vector.addElement(new Option("\tepsilon (default = 0.05)", "epsilon",
				1, "-e <double>"));
		vector.addElement(new Option(
				"\tsubspace overlap threshold (default = 0.90)",
				"subsapceOverlapThreshold", 1, "-s <double>"));
		vector.addElement(new Option(
				"\tinstance overlap threshold (default = 0.2)",
				"instanceOverlapThreshold", 1, "-i <double>"));
		vector.addElement(new Option("\twidth (default = 1.0)", "width", 1,
				"-w <double>"));
		vector.addElement(new Option("\tgamma (default = 0.00)", "gamma", 1,
				"-g <double>"));
		return vector.elements();
	}

	public void setOptions(String[] options) throws Exception {
			
		String optionString = Utils.getOption("a", options);
		if (optionString.length() != 0) {
			setAlpha(Double.parseDouble(optionString));
		}

		optionString = Utils.getOption("b", options);
		if (optionString.length() != 0) {
			setBeta(Double.parseDouble(optionString));
		}

		optionString = Utils.getOption("e", options);
		if (optionString.length() != 0) {
			setEpsilon(Double.parseDouble(optionString));
		}

		optionString = Utils.getOption("s", options);
		if (optionString.length() != 0) {
			setSubsapceOverlapThreshold(Double.parseDouble(optionString));
		}

		optionString = Utils.getOption("i", options);
		if (optionString.length() != 0) {
			setInstanceOverlapThreshold(Double.parseDouble(optionString));
		}

		optionString = Utils.getOption("w", options);
		if (optionString.length() != 0) {
			setWidth(Double.parseDouble(optionString));
		}

		optionString = Utils.getOption("g", options);
		if (optionString.length() != 0) {
			setGamma(Double.parseDouble(optionString));
		}

		optionString = Utils.getOption("d", options);
		if (optionString.length() != 0) {
			setDimOverlap(Double.parseDouble(optionString));
		}

		optionString = Utils.getOption("s", options);
		if (optionString.length() != 0) {
			setMinSubspaceSize(Double.parseDouble(optionString));
		}

		optionString = Utils.getOption("x", options);
		if (optionString.length() != 0) {
			setDisjointMode(Boolean.parseBoolean(optionString));
		}
	}

	/**
	 * Gets the current option settings for the OptionHandler.
	 * 
	 * @return String[] The list of current option settings as an array of
	 *         strings
	 */
	public String[] getOptions() {
		String[] options = new String[20]; // = 2 * the number of arguments
		int current = 0;

		options[current++] = "-a";
		options[current++] = "" + alpha;
		options[current++] = "-b";
		options[current++] = "" + beta;
		options[current++] = "-e";
		options[current++] = "" + epsilon;
		options[current++] = "-w";
		options[current++] = "" + width;
		options[current++] = "-o";
		options[current++] = "" + objectOverlapThreshold;
		options[current++] = "-d";
		options[current++] = "" + subspaceOverlapThreshold;
		options[current++] = "-s";
		options[current++] = "" + minSubspaceSize;

		return options;
	}

	public String globalInfo() {
		return "Simple and Efficient Projective Clustering (MOCCA): A Monte "
				+ "Carlo algorithm that performs trials that sample a small "
				+ "subset of the data points to determine the dimensions in which "
				+ "the points are sufficiently close to form a cluster and then "
				+ "searches the rest of the data for data points that are part of "
				+ "the cluster.";
	}

	public double getAlpha() {
		return alpha;
	}

	public void setAlpha(double alpha) {
		if (alpha > 0.0 && alpha < 1.0)
			this.alpha = alpha;
	}

	public double getBeta() {
		return beta;
	}

	public void setBeta(double beta) {
		if (beta > 0.0 && beta < 1.0)
			this.beta = beta;
	}

	public double getEpsilon() {
		return epsilon;
	}

	public void setEpsilon(double epsilon) {
		if (epsilon > 0.0 && epsilon < 1.0)
			this.epsilon = epsilon;
	}

	public double getMu_0() {
		return 0;
	}

	public void setMu_0(double mu_0) {
	}

	public int getNumClusters() {
		return 0;
	}

	public void setNumClusters(int numClusters) {

	}

	public double getW() {
		return width;
	}

	public void setW(double w) {
		if (w > 0.0)
			this.width = w;
	}

	public double getMaxOverlap() {
		return objectOverlapThreshold;
	}

	public void setMaxOverlap(double maxOverlap) {
		this.objectOverlapThreshold = maxOverlap;
	}

	public double getDimOverlap() {
		return subspaceOverlapThreshold;
	}

	public void setDimOverlap(double dimOverlap) {
		if (dimOverlap > 0.0)
			this.subspaceOverlapThreshold = dimOverlap;
	}

	public double getMinSubspaceSize() {
		return minSubspaceSize;
	}

	public void setMinSubspaceSize(double minSubspaceSize) {
		this.minSubspaceSize = minSubspaceSize;
	}

	public boolean isDisjointMode() {
		return false;
	}

	public void setDisjointMode(boolean disjointMode) {
	}

	@Override
	public String getName() {
		return "MOCCA";
	}

	@Override
	public String getParameterString() {
		return "alpha=" + alpha + "; beta=" + beta + "; epsilon=" + epsilon
				+ "; w=" + width + "; maxOverlap=" + objectOverlapThreshold
				+ "; minSubspaceSize=" + minSubspaceSize;
	}

	public static void main(String[] argv) {
		runSubspaceClusterer(new Mocca(), argv);
	}

	// TODO: Figure out how to use this feature
	// @Override
	// public TechnicalInformation getTechnicalInformation() {
	// TechnicalInformation info = new TechnicalInformation(Type.ARTICLE);
	//
	// info.
	//
	// // TODO Auto-generated method stub
	// return null;
	// }
}
